package main

import (
	"context"
	"fmt"
	"regexp"

	"github.com/spf13/cobra"
	apiv1 "k8s.io/api/core/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"

	cloud "github.com/calyptia/api/types"
)

var reHostnameRFC1123 = regexp.MustCompile(`^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$`)

func newCmdCreateAggregatorOnK8s(config *config, testClientSet kubernetes.Interface) *cobra.Command {
	var aggregatorName string
	var noHealthCheckPipeline bool
	var environmentID string
	var tags []string

	loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
	configOverrides := &clientcmd.ConfigOverrides{}

	cmd := &cobra.Command{
		Use:     "kubernetes",
		Aliases: []string{"kube", "k8s"},
		Short:   "Setup a new core instance on Kubernetes",
		RunE: func(cmd *cobra.Command, args []string) error {
			var clientset kubernetes.Interface
			if testClientSet != nil {
				clientset = testClientSet
			} else {
				kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
				kubeClientConfig, err := kubeConfig.ClientConfig()
				if err != nil {
					return err
				}

				clientset, err = kubernetes.NewForConfig(kubeClientConfig)
				if err != nil {
					return err
				}
			}

			ctx := context.Background()

			if aggregatorName != "" && !validHostnameRFC1123(aggregatorName) {
				return fmt.Errorf("invalid aggregator name %q, it must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character", aggregatorName)
			}

			created, err := config.cloud.CreateAggregator(ctx, cloud.CreateAggregator{
				Name:                   aggregatorName,
				AddHealthCheckPipeline: !noHealthCheckPipeline,
				Version:                "", // TODO
				EnvironmentID:          environmentID,
				Tags:                   tags,
			})
			if err != nil {
				return fmt.Errorf("could not create core instance at calyptia cloud: %w", err)
			}

			if configOverrides.Context.Namespace == "" {
				configOverrides.Context.Namespace = apiv1.NamespaceDefault
			}

			k8sClient := &k8sClient{
				Interface:    clientset,
				namespace:    configOverrides.Context.Namespace,
				projectID:    config.projectID,
				projectToken: config.projectToken,
				cloudBaseURL: config.baseURL,
			}

			if err := k8sClient.ensureOwnNamespace(ctx); err != nil {
				return fmt.Errorf("could not ensure kubernetes namespace exists: %w", err)
			}

			clusterRole, err := k8sClient.createClusterRole(ctx, created)
			if err != nil {
				return fmt.Errorf("could not create kubernetes cluster role: %w", err)
			}

			fmt.Fprintf(cmd.OutOrStdout(), "cluster role: %q\n", clusterRole.Name)

			serviceAccount, err := k8sClient.createServiceAccount(ctx, created)
			if err != nil {
				return fmt.Errorf("could not create kubernetes service account: %w", err)
			}

			fmt.Fprintf(cmd.OutOrStdout(), "service account: %q\n", serviceAccount.Name)

			binding, err := k8sClient.createClusterRoleBinding(ctx, created, clusterRole, serviceAccount)
			if err != nil {
				return fmt.Errorf("could not create kubernetes cluster role binding: %w", err)
			}

			fmt.Fprintf(cmd.OutOrStdout(), "cluster role binding: %q\n", binding.Name)

			deploy, err := k8sClient.createDeployment(ctx, created, serviceAccount)
			if err != nil {
				return fmt.Errorf("could not create kubernetes deployment: %w", err)
			}

			fmt.Fprintf(cmd.OutOrStdout(), "deployment: %q\n", deploy.Name)

			return nil
		},
	}

	fs := cmd.Flags()
	fs.StringVar(&aggregatorName, "name", "", "Core instance name (autogenerated if empty)")
	fs.BoolVar(&noHealthCheckPipeline, "no-healthcheck-pipeline", false, "Disable health check pipeline creation alongside the core instance")
	fs.StringVar(&environmentID, "environment-id", "", "Calyptia environment ID") // TODO: accept name and/or ID.
	fs.StringSliceVar(&tags, "tags", nil, "Tags to apply to the core instance")
	clientcmd.BindOverrideFlags(configOverrides, fs, clientcmd.RecommendedConfigOverrideFlags("kube-"))

	_ = cmd.RegisterFlagCompletionFunc("environment-id", config.completeEnvironmentIDs)

	return cmd
}

func validHostnameRFC1123(s string) bool {
	return reHostnameRFC1123.MatchString(s)
}
